üìò Question√°rio ‚Äì Cap√≠tulo 4.01 (Objects)
O que diferencia objetos de tipos primitivos em JavaScript?
    Os tipos primitivos trabalham com um valor √∫nico simples. S√£o imut√°veis (quando se usa um m√©todo, um novo √© criado), s√£o armazenados em stock memory (mais leve e r√°pida) e n√£o permitem criar seus m√©todos pr√≥prios, mas sim pr√©-definidos pela linguagens. Os objetos s√£o mut√°veis. Qualquer propriedade pode ser alterada diretamente (obj.name = "treloso") realmente muda o objeto. Pode conter in√∫meros valores de v√°rios tipos, s√£o armazenados em heap memory (mais flex√≠vel, mas mais pesada) e s√£o manipulados por refer√™ncia, ou seja, duas vari√°veis podem apontar para um mesmo objeto, sem criar outro na mem√≥ria.

Quais s√£o as duas formas de criar um objeto vazio?
    Um √© o modo "constructor" (new Object()), o outro √© o modo "literal" (let object = {};).

Explique a diferen√ßa entre dot notation e bracket notation.
    O dot notation permite acessar as propriedades dentro dos objetos (objeto.propriedade). Por√©m ele n√£o consegue identificar propriedades com nomes em 'string', como propriedades espa√ßadas. Para tal, a nota√ß√£o de colchete (bracket notation) √© utilizada (objeto["propriedade string"]).

O que s√£o propriedades computadas e como funcionam?
    Propriedades computadas s√£o colchetes utilizados em nomes de propriedades de objetos (chamados 'chaves') que permitem adicionar vari√°veis externas em seu nome. Por exemplo, uma vari√°vel externa "let fruta = 'banana';" poderia ser adicionada nesse nome: "{[fruta]: 2}" --> {banana: 2};
    

O que significa ‚Äúproperty value shorthand‚Äù?
    √â uma abrevia√ß√£o para quando o nome e o valor de uma propriedade s√£o a mesma coisa. O mesmo que "{nome: nome}", ou "{idade: idade}".

H√° restri√ß√µes para nomes de propriedades em objetos? Explique.
    H√° apenas uma restri√ß√£o, sendo ela o uso de '__proto__'. Todas as chaves dos objetos s√£o transformadas em strings, ent√£o n√£o h√° problema em utilizar palavras reservadas da linguagem (digo que a linguagem permite, n√£o que deva ser utilizado). Mas quando se fala em '__proto__', √© algo que quando chamado com dot notation com de colchete, entra em 'prototypes' de objetos, que √© um assunto posterior.

Qual a diferen√ßa entre usar delete obj.prop e atribuir undefined a uma propriedade?
    Deletar propriedades no geral fazem que ela seja '== undefined'. Isso acontece com qualquer propriedade que n√£o exista no objeto. Por√©m, ao atribuir 'undefined' em uma propriedade existente faz com que ela ainda retorne undefined, mas ela existe. Para verificar se essa propriedade realmente existe, pode-se usar o operador 'in'.

Como o operador in funciona e em que casos √© mais √∫til que comparar com undefined?
    Ele verifica se existe propriedade 'x' dentro do objeto 'y'. Ela √© mais √∫til em condi√ß√µes de condicionais, para verificar se h√° uma propriedade espec√≠fica no objeto, ou em loop (for...in), para iterar conforme existir propriedades no objeto.

Explique como o loop for..in percorre propriedades de um objeto.
    Depende de como est√° organizado os par√™nteses do loop, mas normalmente o loop avalia se o objeto tem propriedades. Tendo-as, ele vai atravessar cada propriedade e cabe ao corpo da fun√ß√£o decidir o que fazer. √â poss√≠vel manipular todos os dados (chaves, valores).

Como funciona a ordena√ß√£o de propriedades num√©ricas versus n√£o num√©ricas em objetos?
    A ordena√ß√£o desse tipo √© um tanto curiosa. Basicamente, existem 'propriedades inteiras', sendo elas strings que podem ser convertidas para n√∫meros e vice-versa sem alterar seu valor. Ent√£o '49' viraria 49. Mas '+49' ou '1.2', n√£o, pois n√£o √© inteiro. O ponto √© que, essas propriedades inteiras seguem a ordem crescente (a partir do 1). Logo, a ordem das propriedades viria desse jeito. Basta faz√™-los n√£o inteiros para seguir a ordem de cria√ß√£o.

üìò Question√°rio ‚Äì Cap√≠tulo 4.02 (Object references and copying)
Qual a diferen√ßa entre copiar um valor primitivo e copiar um objeto?
    Ao fazer uma c√≥pia de um valor primitivo (como de 'let number = 1;'), na verdade √© criado um novo valor que armazena a vari√°vel 'number'. Com essa nova c√≥pia, n√£o √© poss√≠vel transformar o valor da vari√°vel original atrav√©s da c√≥pia, pois cada vari√°vel tem seu espa√ßo √∫nico na mem√≥ria. √â simplesmente atribuir o valor de 'number' para uma outra vari√°vel.

    J√° com objetos, esse tipo de c√≥pia n√£o √© poss√≠vel, pois um objeto √© alcan√ßado por refer√™ncia. Muitas vari√°veis igualadas a um objeto s√≥ n√£o vai criar v√°rias c√≥pias, mas sim apontar para o mesmo objeto. Prova disso √© que ao mudar as propriedades do objeto em qualquer que seja a vari√°vel, ir√° alterar os do original. Para c√≥pias de objetos h√° regras espec√≠ficas.

O que significa dizer que objetos s√£o armazenados ‚Äúpor refer√™ncia‚Äù?
    Que cada objeto √© √∫nico na mem√≥ria e, portanto, vari√°veis n√£o guardam o valor do objeto, mas apontam para ele. Isso possibilita muitas vari√°veis apontarem para um objeto s√≥.

Se duas vari√°veis apontam para o mesmo objeto, o que acontece ao modificar uma propriedade?
    Ambas sofrer√£o mudan√ßa, pois √© o mesmo objeto, n√£o uma c√≥pia.

Objetos criados com const podem ser modificados? Explique.
    Sim. Nesse caso, o que 'const' considera como constante √© a refer√™ncia para o mesmo objeto. Ent√£o os valores internos dos objetos podem ser alterados, por√©m o objeto tem que ser o mesmo.

O que √© uma shallow copy e como pode ser feita em JavaScript?
    Shallow copy √© uma c√≥pia superficial de um objeto. Isso quer dizer que apenas o primeiro n√≠vel das propriedades podem ser copiadas de forma correta. Se houver outros objetos aninhados dentro das propriedades, n√£o ser√£o copiados. Isso pode ser feito com o m√©todo 'Object.assign(target, source)'.

O que √© uma deep copy e por que ela √© necess√°ria em alguns casos?
    A deep copy √© um m√©todo que √© utilizado quando h√° objetos aninhados nas propriedades, permitindo a c√≥pia total dos conte√∫dos. Mas h√° uma limita√ß√£o: fun√ß√µes.

Explique como funciona o m√©todo Object.assign.
    O 'Object.assign' usa dois par√¢metros: "target", sendo o objeto no qual a c√≥pia ir√° ficar (geralmente um objeto vazio), e "sources", podendo ser v√°rios objetos diferentes os quais as propriedades ser√£o copiadas todas para o objeto "target".

Qual a diferen√ßa entre Object.assign e structuredClone?
    O primeiro n√£o permite a c√≥pia de propriedades aninhadas. J√° o segundo, permite, mas com a limita√ß√£o de fun√ß√µes.

O que acontece ao tentar clonar um objeto com fun√ß√µes usando structuredClone?
    Retorna um erro, pois o algoritmo que faz o structred clone n√£o suporta fun√ß√µes, j√° que elas n√£o s√£o somente dados, mas tamb√©m c√≥digos execut√°veis. √â uma entidade muito complexa para esse algoritmo.

Cite uma biblioteca popular que oferece clonagem profunda.
    A biblioteca 'Lodash'.

üìò Question√°rio ‚Äì Cap√≠tulo 4.03 (Garbage collection)
O que √© garbage collection em JavaScript?
    √â um algoritmo que faz otimiza√ß√µes na execu√ß√£o do c√≥digo atrav√©s da exclus√£o de objetos.

Explique o conceito de reachability.
    √â basicamente o que √© 'alcan√ß√°vel' no c√≥digo. Tudo aquilo que √© acess√≠vel a partir dos 'roots'.

O que s√£o ‚Äúroots‚Äù no contexto da coleta de lixo?
    S√£o valores sempre acess√≠veis, que servem como base para avaliar o alcance de objetos. Alguns exemplos s√£o: vari√°veis globais, fun√ß√µes em execu√ß√£o e suas vari√°veis locais, fun√ß√µes globais.

O que acontece quando uma vari√°vel que referencia um objeto √© definida como null?
    Dependendo do contexto, caso essa seja a sua √∫nica refer√™ncia, o objeto √© denominado como "unreachable (inalcan√ß√°vel)". Ou seja, objeto √© exclu√≠do da mem√≥ria pelo garbage collection, pois ele n√£o tem mais nenhuma refer√™ncia.

Explique o exemplo de objetos interligados (husband e wife) e como se tornam inacess√≠veis.
    Feito.

O que √© uma ‚Äúilha de objetos‚Äù e como ela pode ser removida da mem√≥ria?


Descreva o funcionamento b√°sico do algoritmo mark-and-sweep.


Quais s√£o algumas otimiza√ß√µes modernas usadas pelos motores JavaScript para coleta de lixo?


Por que n√£o √© poss√≠vel for√ßar manualmente a execu√ß√£o do garbage collector?


Qual a diferen√ßa entre ‚Äúreferenciado‚Äù e ‚Äúacess√≠vel‚Äù?

üìò Question√°rio ‚Äì Cap√≠tulo 4.04 (Object methods, "this")
O que √© um m√©todo em um objeto?

Qual a diferen√ßa entre declarar uma fun√ß√£o fora do objeto e atribu√≠-la como m√©todo depois?

O que significa OOP e como objetos se relacionam com esse paradigma?

Explique a sintaxe abreviada de m√©todos em objetos.
    {func: function() {iaujjsdp√ßalsfd}} {func() {}}

O que √© o this em JavaScript e como seu valor √© determinado?


Por que usar this √© mais confi√°vel do que referenciar diretamente o nome do objeto?

O que acontece se chamarmos uma fun√ß√£o que usa this fora de qualquer objeto, em modo estrito?

Qual √© o valor de this em modo n√£o estrito quando uma fun√ß√£o √© chamada sem objeto?

Como arrow functions lidam com this?

Explique a diferen√ßa entre obj.f() e f() em rela√ß√£o ao valor de this.

üìò Question√°rio ‚Äì Cap√≠tulo 4.05 (Constructor, operator "new")
Qual a principal vantagem de usar fun√ß√µes construtoras em vez de literais {...}?

Quais conven√ß√µes devem ser seguidas ao criar uma fun√ß√£o construtora?

O que acontece internamente quando uma fun√ß√£o √© chamada com new?

O que √© new.target e para que serve?

√â poss√≠vel chamar uma fun√ß√£o construtora sem new? O que acontece?

O que acontece se uma fun√ß√£o construtora retornar explicitamente um objeto?

E se retornar um valor primitivo?

√â permitido omitir par√™nteses ao usar new?

Como adicionar m√©todos diretamente dentro de uma fun√ß√£o construtora?

Cite exemplos de objetos internos do JavaScript que usam construtores.


üìò Question√°rio ‚Äì Cap√≠tulo 4.06 (Mesclando conceitos)
Explique como o uso de structuredClone pode ser √∫til em objetos criados por construtores.

O que acontece se clonarmos superficialmente (Object.assign) um objeto que cont√©m m√©todos com this?

Como o garbage collector lida com objetos criados por construtores quando n√£o h√° mais refer√™ncias a eles?

Qual a diferen√ßa entre copiar uma refer√™ncia de objeto criado com new e criar um clone profundo dele?

Como arrow functions dentro de construtores interagem com o this herdado?

D√™ um exemplo de situa√ß√£o em que m√©todos de objetos e refer√™ncias se combinam para causar comportamento inesperado.